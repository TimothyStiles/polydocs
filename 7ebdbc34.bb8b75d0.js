(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{156:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(2),r=n(9),o=(n(0),n(172)),i={id:"library-io",title:"Sequence Input Output"},c={id:"library-io",isDocsHomePage:!1,title:"Sequence Input Output",description:"At the center of Poly's annotated sequence support is the AnnotatedSequence struct. Structs are kind of Go's answer to objects in other languages. They provide a way of making custom datatypes and methods for developers to use. More on that here, here, and here.",source:"@site/docs/library-io.md",permalink:"/polydocs/docs/library-io",editUrl:"https://github.com/timothystiles/poly/edit/prime/docs/library-io.md",sidebar:"someSidebar",previous:{title:"Hashing Sequences",permalink:"/polydocs/docs/cli-hashing"},next:{title:"Hashing Sequences",permalink:"/polydocs/docs/library-hashing"}},s=[{value:"Readers",id:"readers",children:[]},{value:"AnnotatedSequence structs",id:"annotatedsequence-structs",children:[{value:"AnnotatedSequence.Meta",id:"annotatedsequencemeta",children:[]},{value:"AnnotatedSequence.Features",id:"annotatedsequencefeatures",children:[]},{value:"AnnotatedSequence.Sequence",id:"annotatedsequencesequence",children:[]}]},{value:"Writers",id:"writers",children:[]},{value:"Parsers",id:"parsers",children:[]},{value:"Builders",id:"builders",children:[]},{value:"More Info",id:"more-info",children:[]}],b={rightToc:s};function u(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},b,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"At the center of Poly's annotated sequence support is the ",Object(o.b)("inlineCode",{parentName:"p"},"AnnotatedSequence")," struct. Structs are kind of Go's answer to objects in other languages. They provide a way of making custom datatypes and methods for developers to use. More on that ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://tour.golang.org/moretypes/2"}),"here"),", ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://gobyexample.com/methods"}),"here"),", and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.golang-book.com/books/intro/9"}),"here"),"."),Object(o.b)("p",null,"Anywho. ",Object(o.b)("inlineCode",{parentName:"p"},"poly")," centers around reading in various annotated sequence formats like genbank, or gff and parsing them into an ",Object(o.b)("inlineCode",{parentName:"p"},"AnnotatedSequence")," to do stuff with them. Whether that's being written out to JSON or being used by ",Object(o.b)("inlineCode",{parentName:"p"},"poly")," itself. Here are some examples."),Object(o.b)("h2",{id:"readers"},"Readers"),Object(o.b)("p",null,"For all supported file formats ",Object(o.b)("inlineCode",{parentName:"p"},"poly")," supports a reader. A reader is a function literally named ",Object(o.b)("inlineCode",{parentName:"p"},"ReadJSON(path)"),", ",Object(o.b)("inlineCode",{parentName:"p"},"ReadGbk(path)"),", or ",Object(o.b)("inlineCode",{parentName:"p"},"ReadGff(path)")," that takes one argument - a filepath where your file is located, and returns an ",Object(o.b)("inlineCode",{parentName:"p"},"AnnotatedSequence")," struct."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'  bsubAnnotatedSequence := ReadGbk("data/bsub.gbk")\n  ecoliAnnotatedSequence := ReadGff("data/ecoli-mg1655.gff")\n  puc19AnnotatedSequence := ReadJSON("data/puc19static.json")\n')),Object(o.b)("p",null,"These AnnotatedSequence structs contain all sorts of goodies but can be broken down into three sub main structs. ",Object(o.b)("inlineCode",{parentName:"p"},"AnnotatedSequence.Meta"),", ",Object(o.b)("inlineCode",{parentName:"p"},"AnnotatedSequence.Features"),", and ",Object(o.b)("inlineCode",{parentName:"p"},"AnnotatedSequence.Sequence"),"."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Before we move on with the rest of IO I think it'd be good to go over these sub structs in the next section but of course you can skip to ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"#writers"}),"writers")," if you'd like.")),Object(o.b)("h2",{id:"annotatedsequence-structs"},"AnnotatedSequence structs"),Object(o.b)("p",null,"Like I just said these AnnotatedSequence structs contain all sorts of goodies but can be broken down into three main sub structs:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#annotatedsequencemeta"}),"AnnotatedSequence.Meta")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#annotatedsequencefeatures"}),"AnnotatedSequence.Features")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("a",Object(a.a)({parentName:"li"},{href:"#annotatedsequencesequence"}),"AnnotatedSequence.Sequence"))),Object(o.b)("p",null,"Here's how the AnnotatedSequence struct is actually implemented as of ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TimothyStiles/poly/blob/c4fc7e6f6cdbd9e5ed2d8ffdbeb206d1d5a8d720/io.go#L108"}),"commit c4fc7e"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"  // AnnotatedSequence holds all sequence information in a single struct.\n  type AnnotatedSequence struct {\n    Meta     Meta\n    Features []Feature\n    Sequence Sequence\n  }\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"You can check out the original implementation ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TimothyStiles/poly/blob/c4fc7e6f6cdbd9e5ed2d8ffdbeb206d1d5a8d720/io.go#L108"}),"here")," but I warn you that this is a snapshot and likely has been updated since last writing.")),Object(o.b)("h3",{id:"annotatedsequencemeta"},"AnnotatedSequence.Meta"),Object(o.b)("p",null,"The Meta substruct contains various meta information about whatever record was parsed. Things like name, version, genbank references, etc."),Object(o.b)("p",null,"So if I wanted to get something like the Genbank Accession number for a AnnotatedSequence I'd get it like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'  bsubAnnotatedSequence := ReadGbk("data/bsub.gbk")\n  bsubAccessionNumber := bsubAnnotatedSequence.Meta.Accession\n')),Object(o.b)("p",null,"Same goes for a lot of other stuff:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'  bsubAnnotatedSequence := ReadGbk("data/bsub.gbk")\n\n  // Getting genbank division\n  bSubGenbankDivision := bsubAnnotatedSequence.Meta.GenbankDivision\n\n  // Getting genbank organism\n  bsubGenbankOrganism := bsubAnnotatedSequence.Meta.Organism\n')),Object(o.b)("p",null,"Here's how the Meta struct is actually implemented in ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TimothyStiles/poly/blob/c4fc7e6f6cdbd9e5ed2d8ffdbeb206d1d5a8d720/io.go#L34"}),"commit c4fc7e")," which is the latest as of writing."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"  // Meta Holds all the meta information of an AnnotatedSequence struct.\n  type Meta struct {\n    Name            string\n    GffVersion      string\n    RegionStart     int\n    RegionEnd       int\n    Size            int\n    Type            string\n    GenbankDivision string\n    Date            string\n    Definition      string\n    Accession       string\n    Version         string\n    Keywords        string\n    Organism        string\n    Source          string\n    Origin          string\n    Locus           Locus\n    References      []Reference\n    Primaries       []Primary\n}\n")),Object(o.b)("p",null,"You'll notice that there are actually three more substructs towards the bottom. They hold extra genbank specific information that's handy to have grouped together. More about how genbank files are structered can be found ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.ncbi.nlm.nih.gov/Sitemap/samplerecord.html"}),"here"),"."),Object(o.b)("h3",{id:"annotatedsequencefeatures"},"AnnotatedSequence.Features"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Features")," substruct is actually a slice (golang term for what is essentially a dynamic length list) of ",Object(o.b)("inlineCode",{parentName:"p"},"Feature")," structs that can be iterated through. For example if you wanted to iterate through an ",Object(o.b)("inlineCode",{parentName:"p"},"AnnotatedSequence"),"'s features and get their name (i.e GFP) and type (i.e CDS) you'd do it like this."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'  bsubAnnotatedSequence := ReadGbk("data/bsub.gbk")\n  for feature in := range bsubAnnotatedSequence.Features {\n    fmt.Println(feature.Name + " " + feature.Type)\n  }\n')),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Feature")," struct has about 10 or so fields which you can learn more about from this section in ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TimothyStiles/poly/blob/c4fc7e6f6cdbd9e5ed2d8ffdbeb206d1d5a8d720/io.go#L80"}),"commit c4fc7e"),"."),Object(o.b)("h3",{id:"annotatedsequencesequence"},"AnnotatedSequence.Sequence"),Object(o.b)("p",null,"The AnnotatedSequence Sequence substruct is by far the most basic and critical. Without it well, you ain't go no DNA. The substruct itself has 4 simple fields."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),"  // Sequence holds raw sequence information in an AnnotatedSequence struct.\n  type Sequence struct {\n    Description  string\n    Hash         string\n    HashFunction string\n    Sequence     string\n  }\n")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Description"),", ",Object(o.b)("inlineCode",{parentName:"p"},"Hash"),", and ",Object(o.b)("inlineCode",{parentName:"p"},"HashFunction")," are at all identifying fields of the Sequence string. The ",Object(o.b)("inlineCode",{parentName:"p"},"Description")," is the same kind of short description you'd find in a ",Object(o.b)("inlineCode",{parentName:"p"},"fasta")," or ",Object(o.b)("inlineCode",{parentName:"p"},"fastq")," file. The ",Object(o.b)("inlineCode",{parentName:"p"},"Hash")," and ",Object(o.b)("inlineCode",{parentName:"p"},"HashFunction")," are used to create a unique identifier specify to the sequence string which you'll learn more about in the next chapter on sequence hashing."),Object(o.b)("p",null,"To get an AnnotatedSequence sequence you can address it like so:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'  bsubAnnotatedSequence := ReadGbk("data/bsub.gbk")\n  bsubSequenceString := bsubAnnotatedSequence.Sequence.Sequence\n')),Object(o.b)("h2",{id:"writers"},"Writers"),Object(o.b)("p",null," ",Object(o.b)("inlineCode",{parentName:"p"},"poly")," tries to supply a writer for all supported file formats that have a reader. Currently we have two writers. One for ",Object(o.b)("inlineCode",{parentName:"p"},".json"),", and the other ",Object(o.b)("inlineCode",{parentName:"p"},".gff")," with genbank(",Object(o.b)("inlineCode",{parentName:"p"},".gb")," ",Object(o.b)("inlineCode",{parentName:"p"},".gbk"),") ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TimothyStiles/poly/issues/4"}),"on the way"),"."),Object(o.b)("p",null," Writers take two arguments. The first is an AnnotatedSequence struct, the second is a path to write out to."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),' // getting AnnotatedSequence(s) to write out again.\n bsubAnnotatedSequence := ReadGbk("data/bsub.gbk")\n\n // writing out gbk file input as json.\n WriteJSON(bsubAnnotatedSequence, "data/bsub.json")\n\n // writing out gbk file input as gff.\n WriteGff(bsubAnnotatedSequence, "data/bsub.json")\n')),Object(o.b)("h2",{id:"parsers"},"Parsers"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"poly")," parsers are what actually parse input files from a string without any of the system IO. This is particularly useful if you're like me and have an old database holding genbank files as strings. You can take those strings from a database or whatever and just pass them to ",Object(o.b)("inlineCode",{parentName:"p"},"ParseGbk()"),", or ",Object(o.b)("inlineCode",{parentName:"p"},"ParseGff()")," and they'll convert them into AnnotatedSequence structs."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'  puc19AnnotatedSequence := ParseGbk("imagine this is actually a gbk in string format.")\n')),Object(o.b)("p",null,"That's it. The reason we don't have a ",Object(o.b)("inlineCode",{parentName:"p"},"ParseJSON()")," is that golang, like almost all languages, already has a standard library to handle that."),Object(o.b)("h2",{id:"builders"},"Builders"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"poly")," builders take AnnotatedSequence structs and use them to build strings for different file formats. Currently ",Object(o.b)("inlineCode",{parentName:"p"},"poly")," only supports a ",Object(o.b)("inlineCode",{parentName:"p"},"BuildGff()")," We're working on a ",Object(o.b)("inlineCode",{parentName:"p"},"BuildGbk()")," and with golang's standard library there's no need for use to write a ",Object(o.b)("inlineCode",{parentName:"p"},"BuildJSON"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-go"}),'  // generating an AnnotatedSequence struct from a gff file.\n  ecoliAnnotatedSequence := ReadGff("data/ecoli-mg1655.gff")\n\n  // generating a gff string that then can be piped to stdout or written to a database.\n  ecoliGffString := BuildGff(ecoliAnnotatedSequence)\n')),Object(o.b)("h2",{id:"more-info"},"More Info"),Object(o.b)("p",null,"For more info about IO check out the most current ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TimothyStiles/poly/blob/prime/io.go"}),"code")," and ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TimothyStiles/poly/blob/prime/io_test.go"}),"tests")," and maybe open a ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/TimothyStiles/poly/issues/new/choose"}),"pull request")," for improvements."))}u.isMDXComponent=!0},172:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var b=r.a.createContext({}),u=function(e){var t=r.a.useContext(b),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},l=function(e){var t=u(e.components);return r.a.createElement(b.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},p=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,b=s(e,["components","mdxType","originalType","parentName"]),l=u(n),p=a,h=l["".concat(i,".").concat(p)]||l[p]||d[p]||o;return n?r.a.createElement(h,c(c({ref:t},b),{},{components:n})):r.a.createElement(h,c({ref:t},b))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var b=2;b<o;b++)i[b]=n[b];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}p.displayName="MDXCreateElement"}}]);